---
description:
globs:
alwaysApply: false
---
# Testing Guidelines

Everly backend follows comprehensive testing practices to ensure code quality and reliability.

## Testing Structure

- Place test files in the `tests/` directory
- Mirror the application directory structure
- Name test files with `test_` prefix
- Group tests by domain and functionality

## Test Types

- **Unit Tests**: Test individual functions and methods in isolation
- **Integration Tests**: Test component interactions with mocked dependencies
- **API Tests**: Test API endpoints with test client
- **Database Tests**: Test database interactions with test database
- **End-to-End Tests**: Test complete workflows

## Test Framework

- Use pytest as the testing framework
- Use pytest-asyncio for testing async functions
- Use pytest-cov for tracking test coverage

## Mocking

- Use pytest monkeypatch for simple mocks
- Use unittest.mock for more complex mocking
- Create fixture factories for common test data

## Database Testing

- Use MongoDB memory server for database tests
- Create isolated test databases
- Reset database state between tests

```python
@pytest.fixture
async def test_db():
    """Create a test database connection."""
    from app.db.connection import connect_to_mongo, disconnect_from_mongo
    
    # Connect to test database
    await connect_to_mongo(settings.TEST_MONGODB_URL)
    
    yield
    
    # Disconnect and cleanup
    await disconnect_from_mongo()
```

## API Testing

- Use FastAPI TestClient for API tests
- Test all endpoints with various inputs
- Verify status codes, response formats, and data

```python
@pytest.fixture
def test_client():
    """Create a test client for the FastAPI app."""
    from app.main import app
    from fastapi.testclient import TestClient
    
    return TestClient(app)

def test_get_diary_entry(test_client, create_test_user, create_test_diary):
    """Test retrieving a diary entry."""
    user = create_test_user()
    diary = create_test_diary(user_id=user.id)
    
    response = test_client.get(
        f"/api/v1/diaries/{diary.id}",
        headers={"Authorization": f"Bearer {user.generate_token()}"}
    )
    
    assert response.status_code == 200
    assert response.json()["status"] == "success"
    assert response.json()["data"]["id"] == str(diary.id)
```

## Authentication Testing

- Create test fixtures for authenticated clients
- Test both authenticated and unauthenticated access
- Test different permission levels

## Test Data

- Create fixture functions for test data generation
- Use factory patterns for complex object creation
- Keep test data isolated between tests

## Coverage Requirements

- Maintain minimum 85% test coverage for new code
- Aim for 100% coverage of critical components
- Include coverage reports in CI/CD pipeline

## Test Documentation

- Document test cases with clear docstrings
- Explain the purpose of each test
- Document any complex test setup

## CI/CD Integration

- Run tests automatically on every pull request
- Block merges if tests fail
- Include coverage reports in CI results
