---
description:
globs:
alwaysApply: false
---
# Authentication Guidelines

Everly uses Google OAuth for authentication with JWT tokens for session management.

## Authentication Flow

1. User initiates login via Google OAuth
2. Backend receives authorization code
3. Backend exchanges code for access token with Google
4. Backend verifies token and extracts user information
5. Backend creates or updates user in database
6. Backend issues JWT token for subsequent API calls

## Google OAuth Integration

- Register application in Google Developer Console
- Configure allowed redirect URIs
- Request minimum required scopes
- Store Google OAuth credentials securely

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2AuthorizationCodeBearer
from app.services.auth import verify_google_token, create_access_token

oauth2_scheme = OAuth2AuthorizationCodeBearer(
    authorizationUrl="https://accounts.google.com/o/oauth2/auth",
    tokenUrl="/api/v1/auth/google/callback"
)

@router.post("/google/callback")
async def google_auth_callback(code: str):
    """Process Google OAuth callback."""
    try:
        # Exchange code for token
        google_token = await exchange_code_for_token(code)
        
        # Verify token and get user info
        user_info = await verify_google_token(google_token)
        
        # Find or create user
        user = await find_or_create_user(
            email=user_info["email"],
            name=user_info.get("name"),
            picture=user_info.get("picture")
        )
        
        # Create access token
        access_token = create_access_token(
            data={"sub": str(user.id), "email": user.email}
        )
        
        return {
            "status": "success",
            "data": {
                "access_token": access_token,
                "token_type": "bearer"
            }
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication failed",
        )
```

## JWT Token Management

- Use RS256 algorithm for JWT signing
- Store private key securely
- Set reasonable expiration time (e.g., 7 days)
- Include essential claims only
- Implement token refresh mechanism

## User Authentication

- Create a Depends function for requiring authentication
- Verify JWT token in each protected endpoint
- Extract user ID from token
- Load user from database

```python
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """Get the current authenticated user from JWT token."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        # Decode JWT token
        payload = jwt.decode(
            token, 
            settings.JWT_PUBLIC_KEY, 
            algorithms=[settings.JWT_ALGORITHM]
        )
        
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        
        # Find user in database
        user = await get_user_by_id(user_id)
        if user is None:
            raise credentials_exception
            
        return user
    except JWTError:
        raise credentials_exception
```

## Permission Levels

- Define permission levels in user model
- Create depends functions for different permission levels
- Check permissions in protected endpoints

## Security Measures

- Store JWT token securely on client side
- Implement token revocation mechanism
- Use HTTPS for all communications
- Set secure and HTTP-only cookies
- Implement CSRF protection

## Session Management

- Track active sessions in Redis
- Allow users to view and revoke active sessions
- Expire inactive sessions automatically

## Authentication Testing

- Create test fixtures for different user types
- Mock Google OAuth in tests
- Test token validation and expiration
